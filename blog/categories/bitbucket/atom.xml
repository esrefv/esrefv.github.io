<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: bitbucket | Viduslu]]></title>
  <link href="http://esrefv.github.io/blog/categories/bitbucket/atom.xml" rel="self"/>
  <link href="http://esrefv.github.io/"/>
  <updated>2016-11-06T18:56:14+03:00</updated>
  <id>http://esrefv.github.io/</id>
  <author>
    <name><![CDATA[E. VIDUSLU]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby ile Github-Bitbucket Arasında Çift Yönlü Repository Aktarımı Yapan Script]]></title>
    <link href="http://esrefv.github.io/blog/2016/11/05/ruby-ile-github-bitbucket-arasinda-cift-yonlu-reposityory-aktarimi-yapan-script/"/>
    <updated>2016-11-05T19:00:59+03:00</updated>
    <id>http://esrefv.github.io/blog/2016/11/05/ruby-ile-github-bitbucket-arasinda-cift-yonlu-reposityory-aktarimi-yapan-script</id>
    <content type="html"><![CDATA[<p>Öncelikle başlık biraz uzun oldu arkadaşlar kusura bakmayın :D İlk olarak benden Bitbucket üzerinde bulunan projelerinin Github'a aktarma işlemi için bir script yazmam istendiğinde nasıl yapacağım konusunda en ufak bir fikrim yoktu ve ruby, rials dünyasında çok yeniyim.</p>

<!-- more -->


<p>Sonrasında burada da yazağım gibi adım adım ilerleyerek mükemmel olmasada kullanılabilir bir script ortaya çıkartmaya çalıştım. Kodu bu yazıyı yazmadan önce bitirmiş olduğumdan elimden geldiğince iyileştirme yapmaya çalıştım fakat biraz daha temizlenip düzenlenebileceğine inanıyorum. Umarım işinizi görür.</p>

<h1>Repolarımızın bir dosyaya clone edilmesi</h1>

<p>directoryname adını verdiğim bir değişkende oluşturulacak olan klasörün adını tutacağım ve rubyde &lsquo;Dir&rsquo; sınıfını kullanacağız.</p>

<pre><code>directoryname = "bitbucketproject"
Dir.mkdir(directoryname) unless File.exists?(directoryname)
</code></pre>

<p>Dir.mkdir sayesinde &ldquo;bitbucketproject&rdquo; adında klasörümüz oluşuyor. Ben ubuntu kulladığım için &lsquo;home&rsquo; klasörü altında oluşuyor.</p>

<p>Klonlayacağımız repolarımızı bir repo_list adını verdiğimiz array içinde tutuyoruz.</p>

<pre><code>repo_list = 
["git clone git@github.com:github/example1.git",
"git clone git@bitbucket.org:bitbucket/example2.git"]
</code></pre>

<p>Örnek olarak verdiğim listede terminal üzerinde nasıl clone işlemi yapıyorsak o şekilde yazıyoruz taşımak istediğimiz repoları.</p>

<p>Sonrasında &lsquo;directoryname&rsquo; adını verdiğimiz klasörün içerisine tüm repolarımızı klonlayacak kodu yazıyoruz.</p>

<pre><code> repo_list.each do |repo|
    Dir.chdir(directoryname) do
        system repo 
    end
end
</code></pre>

<p>repo_list içerisindeki tüm repolar bir bir klonlanıyor.</p>

<pre><code class="ruby">    directoryname = "bitbucketproject"
    Dir.mkdir(directoryname) unless File.exists?(directoryname)


    repo_list = 
    ["git clone git@github.com:github/example1.git",
    "git clone git@bitbucket.org:bitbucket/example2.git",
    "git clone git@bitbucket.org:bitbucket/example3.git",
    "git clone git@github.com:github/example4.git",
    "git clone git@bitbucket.org:bitbucket/example5.git",
    "git clone git@github.com:github/example6.git"
    ]

    repo_list.each do |repo|
        Dir.chdir(directoryname) do
            system repo 
        end
    end
</code></pre>

<p>Genel olarak kodumuz bu şekildedir.</p>

<h1>Taşıyacağımız alandaki (Github || Bitbucket) remoteların listelenmesi</h1>

<p>Nasıl klonlayacağımız repolarımızı listeleme işlemi yaptıysak aynı şekilde taşınacağı yerdede oluşturduğumuz repositoryleri aynı sırayla listemize ekliyoruz. (isimlerin aynı olma zorunluluğu yok)</p>

<pre><code>repo_list = 
["git clone git@github.com:github/example1.git",
"git clone git@bitbucket.org:bitbucket/example2.git"]

remote_list = 
["git remote add origin git@bitbucket.org:bitbucket/example1.git",
"git remote add origin git@github.com:github/example2.git"]
</code></pre>

<p>Örnek olarak görebileceğiniz gibi klonlanacak repo_list arrayinde ilk sırada github/example1 var ve karşısında taşıyacağımız yeni repo bitbucket/example1.</p>

<p>Aynı şekilde sıralı olarak remote_list imizi oluşturuyoruz.</p>

<pre><code class="ruby">    remote_list = 
    ["git remote add origin git@bitbucket.org:bitbucket/example1.git",
    "git remote add origin git@github.com:github/example2.git",
    "git remote add origin git@github.com:github/example3.git",
    "git remote add origin git@bitbucket.org:bitbucket/example4.git",
    "git remote add origin git@github.com:github/example5.git",
    "git remote add origin git@bitbucket.org:bitbucket/example6.git"
    ]
</code></pre>

<h1>Yeni remote ları eklemek için klonlanan dosyaları listeleme</h1>

<p>Bu işlemin yapıla bilmesi için tek tek klasörlerin içerisine girilerek &lsquo;git&rsquo; kodu çalıştırılması gerekiyor. &lsquo;directoryname&rsquo; içerisinde bulunan tüm dosyaları listeleyen bir &lsquo;Dir&rsquo; kodu var.</p>

<pre><code class="ruby">    files = Dir.glob(directoryname + "/*")
    files_change = Dir.glob(directoryname + "/*")
</code></pre>

<p>&lsquo;Dir&rsquo; glob belirttiğimiz path içerisindeki dosyaları listeliyor bize. Fakat listeleme tarzı &lsquo;bitbucket/example1&rsquo; şeklinde olduğu için tek tek içerisini gezme açısında güzel, ayrıca bize sadece dosya adı olan &lsquo;example1&rsquo; de lazım olduğundan neden iki tane kullanıyoruz diye düşünebilirsiniz, sıra onda :)</p>

<pre><code class="ruby">    files_change.each do |file_change|
        file_change.slice! directoryname + "/"
    end
</code></pre>

<p>Bu kod sayesinde files_change içerisinde sadece klasör isimlerini tutuyoruz. Yaptığı işlem ise &lsquo;bitbucket/example1&rsquo; şeklinde olan listedeki verilerin önünden &lsquo;bitbucket/&rsquo; ı siliyor ve bize sadece klasör isimlerini bırakıyor.</p>

<h1>Yeni bir remote listesi oluşturma zorunluluğu</h1>

<p>Genel olarak tekli ve ikili olarak test ettiğim bu scriptte çoğul bir deneme yaptığımda klonlanan reponun klasör isminin baş harfine göre bir sapma yaşanıyor ve klonlanan repo başka bir repoya pushlanabiliyordu.</p>

<p>Fakat merak etmeyin kullanıcı sadece repo_list ve remote_list i sırayla girdikten sonra başka bir işlem yapmasına gerek kalmadan biz sıralamayı kodla halledeceğiz.</p>

<pre><code class="ruby">    new_remote_list = Array.new
    order_count = 0
    repo_count = 0  
    files_change.each do |fileschange|  
        repo_list.each  do |repolist| 
            if repolist.include? fileschange
                new_remote_list[repo_count] = remote_list[order_count]
                repo_count += 1
            end
            order_count += 1
        end
        order_count=0   
    end
</code></pre>

<p>Kodumuz bu şekilde. Nasıl çalıştığına gelirsek. files_change bizim &lsquo;example1&rsquo; şeklinde tuttuğumuz klonlanan repolarımızın dosya adı listesi. Ve files_change klasörlerimizi okuduğu sıralamayla bize dosya adı listesi yaratıyor. Bu önemli!! repo_list en başta anlattığım  klonlanacak olan repolarımızın sıralı listesi.</p>

<pre><code class="ruby">    files_change.each do |fileschange|

    end
</code></pre>

<p>Bu blokta klasörlerin okunduğu sırada dosyaları gezeceğiz.</p>

<pre><code class="ruby">    files_change.each do |fileschange|  
        repo_list.each  do |repolist| 

        end
        order_count=0   
    end
</code></pre>

<p>repo_list te ise ilk sırada klonlamak istediğimiz sırada girdiğimiz repository listemiz ve bunları gezeceğiz. Neden mi? Çünkü bu sıra bizim taşıyacağımız yer için kullacağımız remote_list ile aynı olan sıra ve ilk başta dediğim gibi taşıyacağınız yerin repository adı aynı olmak zorunda değil.</p>

<p>repo_list in ilk sırasında &ldquo;github/example1.git&rdquo; var bu klonladığımız repository. Klasörümüzün adı ise example1 , remote_list imizde ise ilk sırada &ldquo;bitbucket/example1.git&rdquo; var buda yeni göndereceğimiz repository.
<code>ruby
    repo_list.each  do |repolist|
            if repolist.include? fileschange
                new_remote_list[repo_count] = remote_list[order_count]
                repo_count += 1
            end
            order_count += 1
        end
</code>
Belirttiğim gibi klon aşamasında klasör isimlerine göre sıralama değişiyor. if koşulu -> repo_list in ilk sırasındaki veride &ldquo;files_change&rdquo; klasör adı geçiyormu diye bakıyoruz. Eğer geçiyorsa new_remote_list[0] dan başlayarak eşleşmeleri içerisine ekle.</p>

<p>Ve sonunda new_remote_list olarak adlandırdığımız okunan klasör sırasına göre yeni bir remote listemiz oluştu.</p>

<p>Örnek ;</p>

<pre><code>repo_list = 
["git clone git@github.com:github/example1.git", ...]
fileschange = "example1"

"git clone git@github.com:github/example1.git" içerisinde "example1" geçiyormu?
</code></pre>

<p>Şeklinde files_change okunan dosyaların listesi olduğu için ilk sırada &lsquo;example4&rsquo; te olabilirdi.</p>

<h1>Yeni remote ları repolarımıza ekleyelim</h1>

<p>Bir projelerimizi commitleri ve eğer master - develop brachleri varsa o şekilde pushlayacağız. Klonlanan projelerin &lsquo;origin remote&rsquo; ları klonlanan yer neresi ise orası kalıyor. Biz onuda silmeden origin_two isminde yeni bir remote ekleyeceğiz.</p>

<pre><code class="ruby">    new_remote_list.each do |new_remote|    
        new_remote.gsub! 'origin', 'origin_two'
    end
</code></pre>

<p>Remote listemizi &lsquo;origin_two&rsquo; olacak şekilde düzenliyoruz.
<code>ruby
    remote_count = 0
    files.each do |file|
        Dir.chdir(file) do          
            remote = new_remote_list[remote_count]                      
            system 'git remote -v'
            system remote
            system 'git remote -v'                  
        end
        remote_count +=1
    end
</code>
Bu kodda tek tek dosyalarımıza girerek &lsquo;git remote add origin_wo &rsquo; kodunu çalıştıracak. &lsquo;git remote -v&rsquo; ise eklenmeden önceki ve sonraki halini ekrana basacak.</p>

<h1>Yeni repomuza pushluyoruz ve origin_two remoteunu siliyoruz</h1>

<pre><code class="ruby">    files.each do |file|
        Dir.chdir(file) do
            system 'git checkout master'
            system 'git branch -a'               
            system 'git push origin_two master'
            system 'git checkout develop'
            system 'git branch -a'
            system 'git push origin_two develop'                
        end     
    end

    remote_remove = 0
    files.each do |file|
        Dir.chdir(file) do
            remote = remote_list[remote_remove]
            system 'git remote -v'
            system 'git remote remove origin_two'   
        end
    remote_remove += 1          
    end
</code></pre>

<p>Bu kodda ilk döngüde öncelikle master branche geçiyoruz. Ve yeni remote umuza &lsquo;origin_two&rsquo; ya masterı pushluyoruz. Sonrasında develop branch için aynı işlemi uyguluyoruz.</p>

<p>İkinci döngüde ise &lsquo;git remote remove&rsquo; ile origin_two remoteumuzu kaldırıyoruz. Aslında kaldırmamızı gerektiren bir durum yok isterseniz kaldırmaya bilirsiniz.</p>

<p>Elimden geldiğince açıklamaları ile anlatmaya çalıştım. Yazı biraz fazla uzun oldu başlık gibi :D Okuduğunuz için teşekkürler.</p>
]]></content>
  </entry>
  
</feed>
